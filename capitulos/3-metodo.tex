%%%% CAPÍTULO 3 - Metodologia

\chapter{Metodologia}\label{cap:Metodologia}
Este capítulo delineia os objetivos e a abordagem da pesquisa, apresentando uma visão geral das questões fundamentais apresentadas. Além disso, não só explica as métricas, ferramentas, repositórios utilizados, como também o método e resultados esperados, relacionados com o cronograma definido para a conclusão do projeto de pesquisa.

% Questões da pesquisa.
\section{Questões de pesquisa}
As questões de pesquisa foram formuladas com base nos objetivos geral e específicos desta monografia. Elas direcionarão a investigação sobre a evolução de projetos de \gls{sds} por meio da análise de métricas de código, de modo a criar um exemplo trabalhado para a \gls{es}, como apresentadas abaixo:

% Questões da pesquisa.
\begin{enumerate}
    \item Como identificar métricas de qualidade de código relevantes para a análise da evolução em \gls{sds}?
    
    \item Quais são os padrões e tendências observados que correspondem a uma melhoria clara do código em \gls{sds}?
    
    \item Como as melhorias de código se refletem nas métricas selecionadas e qual é a relação delas com características não funcionais, como desempenho e segurança em \gls{sds}?
    
    \item Quais são as métricas e características mais relevantes para a seleção de exemplos de código apropriados para a criação de exemplos trabalhados na \gls{es}?
\end{enumerate}

% Abordagem Proposta.
\section{Abordagem proposta}

O presente trabalho propõe o desenvolvimento de uma heurística para identificar exemplos de código-fonte representativos da melhoria da qualidade de software em \gls{sds}, por meio da análise de métricas de código utilizadas na \gls{es}. A heurística visa auxiliar na seleção de trechos de código que permitam a criação de exemplos trabalhados que demonstrem como o código em \gls{sds} se adapta e evolui ao longo do tempo.

A heurística a ser desenvolvida nesta pesquisa baseia-se nas melhorias que podem ser identificadas através das métricas selecionadas. As métricas devem ser capazes de capturar informações valiosas relacionadas à evolução do código em \gls{sds}. Logo, são empregadas ferramentas específicas em repositórios de código aberto cuidadosamente selecionados. 

% Métricas CK.
\subsection{Métricas de software} \label{sec:metricasDeSoftware}
O artigo ``\textit{A Metrics Suite for Object Oriented Design}'' \cite{MetricsSuite} apresenta um conjunto de métricas para avaliação do design de código orientado a objetos, introduzindo métricas cruciais para compreender a complexidade e qualidade do código-fonte. As principais métricas apresentadas no artigo são listadas a seguir.

% Explicação das Métricas CK.
\begin{itemize}
    \item \textbf{\gls{cbo}}: Reflete o grau de acoplamento, ou seja, as dependências que uma classe específica possui, indicando a quantidade de classes diretamente associadas a ela, já que utiliza métodos dessas classes. Um valor elevado sugere maior complexidade e menor flexibilidade, pois mudanças na classe podem impactar várias outras. Não suficiente, demasiado acoplamento diminui o grau de modularidade de uma classe. Observar uma redução no \gls{cbo} ao longo da evolução do código é um indicativo positivo de melhorias na qualidade do código.
    
%    Uma variação da implementação do \gls{cbo}, também denominada \gls{cbom} considera a dependência de classes como uma referência a um objeto do mesmo tipo. Isso significa que, ao adicionar uma simples chamada de método da classe, a métrica é incrementada. 

    \item \textbf{\gls{dit}}: Reflete a profundidade da árvore de herança à qual uma classe depende, indicando a quantidade de ancestrais que uma classe tem. Um valor elevado de \gls{dit} pode indicar uma maior complexidade e potencial para efeitos colaterais ao realizar alterações em alguma das superclasses.
    
    \item \textbf{\gls{lcom}}: Representa o coeficiente de falta de coesão em métodos, mensurando a coesão em uma classe. O valor varia de 0 a 1, onde 0 indica alta coesão e 1 indica falta de coesão. Baixos valores são desejados, indicando que os métodos estão fortemente inter-relacionados, contribuindo para uma classe mais coesa.

    \item \textbf{\gls{noc}}: Indica o número de filhas diretas de uma classe. Um valor alto pode indicar maior reusabilidade, mas também pode aumentar a complexidade, pois a classe pode ter muitas responsabilidades. O equilíbrio é necessário para manter uma estrutura clara e eficiente.

    \item \textbf{\gls{rfc}}: Refere-se ao número de invocações únicas de um método de uma determinada classe, isto é, conta o número de invocações estáticas, avaliando o nível de comunicação entre classes.

    \item \textbf{\gls{wmc}}: Simboliza a soma dos valores de complexidade dos métodos de uma classe específica. Um valor elevado indica que a classe pode ser complexa, com múltiplos métodos, implicando em um custo significativo para o desenvolvimento e manutenção. Além disso, a existência de vários métodos associados a uma classe sugere que ela pode ser menos genérica, sem mencionar o possível impacto nos filhos dessa classe.
\end{itemize}

% Ferramentas Utilizadas e o motivo.
\subsection{Ferramentas}\label{sec:ferramentas}
% Ferramenta CK.
O \gls{ck}\footnote{https://github.com/mauricioaniche/ck} \cite{aniche-ck} é a ferramenta utilizada nesta pesquisa para analisar a qualidade do código-fonte em projetos Java \cite{JavaProgrammingLanguage} por meio de métricas estáticas. Essas métricas fornecem informações valiosas sobre características como complexidade, acoplamento e coesão de classes. A ferramenta em questão apresenta mais de 35 métricas.

% Ferramenta RefactoringMiner.
O \textit{RefactoringMiner} \footnote{https://github.com/tsantalis/RefactoringMiner} \cite{Tsantalis:ICSE:2018:RefactoringMiner} é uma ferramenta no contexto da \gls{es}, especializada em identificar e analisar refatorações de código-fonte. Essa ferramenta fornece uma compreensão aprofundada das mudanças realizadas em um código ao longo do tempo. Com a sua capacidade de reconhecer padrões de refatoração, o \textit{RefactoringMiner} permite que os desenvolvedores analisem como o código foi modificado, de modo a melhorar a qualidade, manutenibilidade e eficiência do software.

% Ferramenta PyDriller.
A biblioteca \textit{PyDriller} \footnote{https://github.com/ishepard/pydriller}\cite{PyDrillerSpadini2018} é um recurso para análise de repositórios de código-fonte escritos em Python. Sua funcionalidade possibilita aos pesquisadores e desenvolvedores explorar e compreender a evolução do código em projetos Python de uma maneira eficiente. O \textit{PyDriller} oferece recursos para extrair informações, como histórico, autoria e mensagens de \textit{commits}, além de detalhes específicos do estado do código em um determinado momento, contribuindo assim para a pesquisa e prática em \gls{es} no contexto de sistemas complexos e interconectados.

% Repositórios.
\subsection{Repositórios}\label{sec:repositorios}
A seguir são apresentados os projetos de código aberto disponíveis no https://github.com, que serão analisados neste trabalho de pesquisa.

% Conceito do Apache Kafka.
O Apache Kafka \cite{KafkaGitHub} é um sistema de mensagens distribuídas, baseado no modelo \textit{publish-subscribe}, que desempenha um papel fundamental na infraestrutura de processamento de eventos em tempo real. Conforme o artigo ``\textit{Apache Kafka: Next Generation Distributed Messaging System}'' \cite{ApacheKafkaNextGenerationDistributedMessagingSystem:2010}, o Kafka é projetado para lidar com fluxos de dados em grande escala, permitindo que organizações processem, armazenem e transmitam dados de maneira eficiente, operando em um modelo de log distribuído, no qual as mensagens são registradas em logs (ou tópicos) que podem ser divididos em partições. 
A estrutura do Apache Kafka é composta por vários componentes, incluindo:

% Elementos estruturais do Apache Kafka.
\begin{itemize}
  \item \textbf{Tópicos}: São canais de mensagens nos quais os dados são publicados e armazenados.
  \item \textbf{Produtores}: São responsáveis por publicar mensagens em tópicos do Kafka.
  \item \textbf{Partições}: Os tópicos podem ser divididos em partições para permitir a distribuição e o processamento paralelo de mensagens.
  \item \textbf{Corretores (Brokers)}: São servidores que armazenam e distribuem as mensagens. Eles desempenham um papel central na arquitetura do Kafka.
  \item \textbf{Consumidores}: São aplicativos que se inscrevem nos tópicos para receber mensagens e processá-las.
  \item \textbf{\gls{zk} (KRaft em 2023)}: No passado, o Kafka dependia do Apache \gls{zk} para gerenciamento de metadados e coordenação. No entanto, em 2023, o Kafka adotou o \textit{KRaft} como substituto, eliminando a dependência do \gls{zk}, com o intuito de deixá-lo mais simples e robusto.
\end{itemize}

% Implicações da estrutura do Kafka.
Essa arquitetura permite a escalabilidade, tolerância a falhas e a distribuição das mensagens em várias máquinas e servidores, tornando-o uma escolha popular em empresas como LinkedIn, X (Twitter), Uber, Foursquare, entre outros para a construção de pipelines de dados em tempo real e sistemas de processamento de eventos \cite{KafkaPoweredBy}. Dessa forma, dada a sua arquitetura, uso no mundo real, além da capacidade do \textit{``Apache Kafka''} lidar com volumes massivos de dados em tempo real, ele torna-se um ótimo candidato a ser estudado.

% Conceito do ZooKeeper.
O \gls{zk} \cite{ZookeeperGitHub} é um serviço de coordenação distribuída amplamente utilizado para sistemas de grande escala na internet. Ele fornece um ambiente confiável e altamente disponível para a coordenação de tarefas entre diversos nós em um cluster distribuído. Na ótica do artigo ``\textit{ZooKeeper: Wait-free coordination for Internet-scale systems}'' \cite{ZooKeeperWaitFree:2010}, o \gls{zk} é baseado em um conjunto de servidores distribuídos que formam o chamado ``\textit{ensemble}''. Cada servidor nesse conjunto mantém uma cópia completa dos dados de configuração e estado do sistema. Os clientes se conectam a qualquer servidor do conjunto e podem ler ou gravar informações. Quando os clientes gravam informações, elas são replicadas para a maioria dos servidores no conjunto antes de serem confirmadas, garantindo assim a consistência dos dados. 

% Conceito do ZooKeeper - Continuação.
O \gls{zk} fornece um sistema de coordenação sem espera (do inglês, ``\textit{wait-free}''), por meio de um mecanismo de observação para permitir que os clientes armazenem dados em \textit{cache} sem ter que gerenciar o \textit{cache} do cliente diretamente. Além disso, a implementação do algoritmo denominado \gls{zab} é responsável por garantir a consistência de dados distribuídos no \gls{zk} por meio do uso do \textit{Two-Phase Commit Protocol} para replicar todas as transações para todos os nós do cluster do \gls{zk}\cite{CloudKarafkaZAB}.

O \textit{``ZooKeeper''} desempenha um papel fundamental na coordenação e gerenciamento de serviços distribuídos. Ele oferece um serviço de consenso altamente confiável para \gls{sds}, garantindo a consistência e a sincronização entre os nós. Essa funcionalidade é crucial para a implementação de serviços distribuídos confiáveis e escaláveis, tornando o \textit{``ZooKeeper''} uma escolha valiosa para este estudo.

% Métodos.
\section{Métodos}\label{sec:metodo}
Este trabalho de pesquisa adota uma abordagem exploratória com o propósito de desenvolver uma heurística que possibilite a seleção criteriosa de códigos representativos de melhorias de software, de acordo com métricas específicas de \textit{código} em projetos de \gls{sds}. O objetivo principal é aprofundar a compreensão desses casos, proporcionando uma análise detalhada da evolução do código em resposta a mudanças nas métricas escolhidas. Esse estudo visa contribuir diretamente para a construção de exemplos trabalhados aplicáveis ao contexto da \gls{es}.

A natureza exploratória da pesquisa pretende proporcionar uma visão mais ampla sobre como as métricas de código em projetos de \gls{sds} refletem melhorias significativas. A heurística em desenvolvimento visa identificar casos exemplares de evolução de código, considerando métricas específicas, selecionadas com base nas melhores práticas e no entendimento profundo das características inerentes aos \gls{sds}.

Para alcançar esses objetivos, serão realizadas análises minuciosas de repositórios de código aberto relevantes na área de \gls{sds}, considerando não apenas a evolução do código-fonte, mas também as mudanças nas métricas escolhidas ao longo do tempo. Na vertente de desempenho, serão investigados elementos que possam impactar a eficiência operacional, enquanto na esfera da segurança, será explorada a possibilidade de correlacionar informações de algum \gls{cve} \cite{cve-details} com alterações específicas no código, proporcionando uma análise abrangente e multifacetada.
A metodologia adotada permite, assim, uma compreensão holística da relação entre a qualidade do código e as métricas específicas selecionadas.

Além disso, a pesquisa visa ir além da mera análise quantitativa, incorporando uma abordagem qualitativa ao desenvolver exemplos trabalhados que demonstrem, de forma clara e pedagogicamente eficaz, como a evolução do código em \gls{sds} pode ser interpretada e compreendida no âmbito da \gls{es}. Essa abordagem qualitativa será fundamental para a construção de um conhecimento prático e aplicável que possa enriquecer o ensino e a prática profissional na área.

\section{Resultados esperados e cronograma}

% Passo a passo e resultados esperados.
\begin{enumerate}
    \item Realizar uma revisão da literatura, explorando estudos sobre métricas de código em \gls{es} e \gls{sds}.
    \\\textbf{Resultado esperado:} Lista de estudos sobre exemplos trabalhados e as respectivas contribuições.

    \item Selecionar um ou mais repositórios \textit{open-source} pertinentes à área de \gls{sds} que servirão como fonte de exemplos de código para análise.
    \\\textbf{Resultado esperado:} Lista de repositórios \textit{open-source} ativamente mantidos e utilizados em aplicações reais selecionados para análise.

    \item Selecionar métricas de código específicas e relevantes apropriadas para avaliar a evolução de código em \gls{sds}, considerando as melhores práticas da área.
    \\\textbf{Resultado esperado:} Lista de métricas de código selecionadas, capazes de refletir melhorias, por exemplo, com relações a desempenho.

    \item Escrita e publicação de um artigo resumido no evento EduComp2024 sobre o projeto e as metodologias utilizadas até o momento.
    \\\textbf{Resultado esperado:} Resumo publicado apresentando o projeto, metodologias e atividades desenvolvidas de fevereiro até abril no EduComp2024.

    \item Selecionar exemplos específicos de código trabalhados nos repositórios escolhidos, aplicando a heurística desenvolvida e justificando a seleção com base em métricas de código.
    \\\textbf{Resultado esperado:} Lista de candidatos potenciais com refatorações significativas, com relação à evolução da qualidade do código.

    \item Avaliar a utilidade educacional dos exemplos de código selecionados, usando-os em um contexto de ensino.
    \\\textbf{Resultado esperado:} Contribuir para o estudo do código de um \gls{sd} no âmbito da \gls{es}.

    \item Escrita e publicação de um artigo resumido no \textit{SBES-Education} sobre os resultados obtidos até o momento, destacando descobertas e contribuições.
    \\\textbf{Resultado esperado:} Resumo publicado apresentando os resultados e contribuições entre abril e junho no \textit{SBES-Education}.
\end{enumerate}

Dessa forma, a Tabela~\ref{table:schedule} apresenta um cronograma de atividades.

\begin{table}[h]
\centering
\caption{Cronograma de atividades}
\label{table:schedule}
\begin{tabular}{lcccccc}
Atividade/Mês & Jan & Fev & Mar & Abr & Mai & Jun  \\
\hline
1 - Revisão da literatura & x & x & x & x & & \\
2 - Seleção de repositórios & x & x & & & & \\
3 - Seleção de métricas & x & x & x & & & \\
4 - Submissão de um resumo no EduComp2024 & & x & x & x & & \\
5 - Seleção de exemplos & & & & x & x & x \\
6 - Avaliação da utilidade educacional & & & & x & x & x \\
7 - Submissão de um resumo no \textit{SBES-Education} & & & & & x & x
\end{tabular}
\end{table}
